<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="排序算法 本文为数据结构与算法之美-王争的学习笔记，如需查看完整内容，请参考链接。  这篇关于排序算法的笔记写了好久，中间事情也比较多，导致写到最后的桶排序时，前面的一些细节忘了好多。 在众多排序算法中，最经典的有以下几种：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序和桶排序。按照时间复杂度可以划分为以下几类：  由上表可知，冒泡排序和插入排序的时间复杂度都是$O(n^2)">
<meta name="keywords" content="编程基础,算法">
<meta property="og:type" content="article">
<meta property="og:title" content="常见排序算法总结">
<meta property="og:url" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/index.html">
<meta property="og:site_name" content="MXQ">
<meta property="og:description" content="排序算法 本文为数据结构与算法之美-王争的学习笔记，如需查看完整内容，请参考链接。  这篇关于排序算法的笔记写了好久，中间事情也比较多，导致写到最后的桶排序时，前面的一些细节忘了好多。 在众多排序算法中，最经典的有以下几种：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序和桶排序。按照时间复杂度可以划分为以下几类：  由上表可知，冒泡排序和插入排序的时间复杂度都是$O(n^2)">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/fb8394a588b12ff6695cfd664afb17cd.jpg">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/1381c1f3f7819ae61ab17455ed7f0b59.jpg">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/4038f64f47975ab9f519e4f739e464e9.jpg">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/9246f12cca22e5d872cbfce302ef4d09.jpg">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/a1ef4cc1999d6bd0af08d8417ee55220.jpg">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/8890cbf63ea80455ce82490a23361134.jpg">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/7b257e179787c633d2bd171a764171a6.jpg">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/b60f61ec487358ac037bf2b6974d2de1.jpg">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/32371475a0b08f0db9861d102474181d.jpg">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/db7f892d3355ef74da9cd64aa926dc2b.jpg">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/95897ade4f7ad5d10af057b1d144a22f.jpg">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/4d892c3a2e08a17f16097d07ea088a81.jpg">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/6643bc3cef766f5b3e4526c332c60adc.jpg">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/086002d67995e4769473b3f50dd96de7.jpg">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/aa03ae570dace416127c9ccf9db8ac05.jpg">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/987564607b864255f81686829503abae.jpg">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/adc75672ef33fa54b023a040834fcbc9.jpg">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/361f4d781d2a2d144dcbbbb0b9e6db29.jpg">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/dd6c62b12b0dc1b3a294af0fa1ce371f.jpg">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/1d730cb17249f8e92ef5cab53ae65784.jpg">
<meta property="og:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/df0cdbb73bd19a2d69a52c54d8b9fc0c.jpg">
<meta property="og:updated_time" content="2019-11-30T15:20:52.161Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="常见排序算法总结">
<meta name="twitter:description" content="排序算法 本文为数据结构与算法之美-王争的学习笔记，如需查看完整内容，请参考链接。  这篇关于排序算法的笔记写了好久，中间事情也比较多，导致写到最后的桶排序时，前面的一些细节忘了好多。 在众多排序算法中，最经典的有以下几种：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序和桶排序。按照时间复杂度可以划分为以下几类：  由上表可知，冒泡排序和插入排序的时间复杂度都是$O(n^2)">
<meta name="twitter:image" content="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/fb8394a588b12ff6695cfd664afb17cd.jpg">






  <link rel="canonical" href="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>常见排序算法总结 | MXQ</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-hopscotch.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/XiangqianMa/" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">MXQ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Keep Moving</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">

    
    
    
      
    

    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">

    
    
    
      
    

    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>站点地图</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">

    
    
    
      
    

    

    <a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益 404</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xiangqianma.github.io/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MXQ">
      <meta itemprop="description" content="Keep Thinking Keep Moving">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MXQ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">常见排序算法总结

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-09 23:35:20" itemprop="dateCreated datePublished" datetime="2019-11-09T23:35:20+08:00">2019-11-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-30 23:20:52" itemprop="dateModified" datetime="2019-11-30T23:20:52+08:00">2019-11-30</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/编程基础/" itemprop="url" rel="index"><span itemprop="name">编程基础</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><blockquote>
<p>本文为<a href="https://time.geekbang.org/column/article/40036" target="_blank" rel="noopener">数据结构与算法之美-王争</a>的学习笔记，如需查看完整内容，请参考链接。</p>
</blockquote>
<p><strong>这篇关于排序算法的笔记写了好久，中间事情也比较多，导致写到最后的桶排序时，前面的一些细节忘了好多。</strong></p>
<p>在众多排序算法中，最经典的有以下几种：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序和桶排序。按照时间复杂度可以划分为以下几类：</p>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/fb8394a588b12ff6695cfd664afb17cd.jpg" style="zoom:50%;"></p>
<p>由上表可知，冒泡排序和插入排序的时间复杂度都是$O(n^2)$，但在实际工程中更倾向于使用插入排序，这是为什么？</p>
<h2 id="如何分析一个排序算法？"><a href="#如何分析一个排序算法？" class="headerlink" title="如何分析一个排序算法？"></a>如何分析一个排序算法？</h2><p>分析一个排序算法要从那几个方面入手？</p>
<h3 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h3><h4 id="最好情况、最坏情况和平均情况时间复杂度"><a href="#最好情况、最坏情况和平均情况时间复杂度" class="headerlink" title="最好情况、最坏情况和平均情况时间复杂度"></a>最好情况、最坏情况和平均情况时间复杂度</h4><p>我们在分析排序算法时，要给出排序算法的最好情况、最坏情况和平均情况时间复杂度，并说明各个情况对应的要排序的原始数据是什么情况。</p>
<p>这样做的原因在于：1. 有些排序算法会区分；2. 要排序的数据中，有些接近有序，有些完全无序，我们需要直到算法在不同数据情况下的表现。</p>
<h4 id="时间复杂度的系数、常数和低阶"><a href="#时间复杂度的系数、常数和低阶" class="headerlink" title="时间复杂度的系数、常数和低阶"></a>时间复杂度的系数、常数和低阶</h4><p>我们在分析时间复杂度时会假设数据的规模非常大，此时便可以忽略时间复杂度中的系数、常数和低阶。但在实际工程中，需要处理的数据一般很小，此时系数、常数和低阶就无法直接忽略。</p>
<h4 id="比较和交换次数"><a href="#比较和交换次数" class="headerlink" title="比较和交换次数"></a>比较和交换次数</h4><p>对于基于比较的排序算法来说，会涉及两种基本的操作：比较和交换。因而，我们在分析排序算法时需要对算法的比较和交换次数进行考虑。</p>
<h3 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h3><p>算法的内存消耗可以通过空间复杂度进行度量，但针对排序算法的空间复杂度分析，引入了一个新的概念：<strong>原地排序</strong>（Sorted in place）。原地排序算法指的是空间复杂度为$O(1)$的排序算法。</p>
<h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h3><blockquote>
<p> 排序算法的稳定性指的是：当待排序的数据中存在相等的数据时，经过排序之后，相等元素之间原有的先后顺序是否不变。</p>
</blockquote>
<p>例如，现在有一组数据：2，9，3，4，8，3，按照大小排序后为：2，3，4，8，9。在这组数据中有两个3，经过某种排序算法之后，如果两个3的前后顺序没有改变，就将这种排序算法称为稳定的排序算法；如果前后顺序发生变化，就将这种排序算法称为不稳定的排序算法。</p>
<p>当待排序的对象为整数时，这一性质似乎没有用。但在实际工程中，待排序的数据往往是具体的对象，对象之间的大小按照某一准则决定。</p>
<p>例如，有一组订单，有金额和下单时间两个性质。我们希望按照金额大小从小到大进行排序，对于金额相同的订单，按照下单时间从早到晚排序。有以下两个思路：</p>
<ul>
<li>先将订单按照金额大小进行排序，再对每一个金额相同的小区间按照下单时间进行排序。实际上，这种排序算法在实现时复杂度较高。</li>
<li>先将订单按照下单时间进行排序，再使用稳定性排序算法按照金额大小进行排序。稳定性排序后，订单首先满足金额从小到大，接着由于具有稳定性，具有相同金额的订单会维持原有的顺序（下单时间）。</li>
</ul>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/1381c1f3f7819ae61ab17455ed7f0b59.jpg" style="zoom:50%;"></p>
<h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p>冒泡排序的操作对象是相邻的两个元素。每一次冒泡操作会对相邻的两个元素进行比较，看是否满足大小要求。如果不满足，就将两个元素交换。一次冒泡至少会让一个元素移动到它应该在的位置，重复n次，就会完成n个数据的排序工作。</p>
<p>以数据4，5，6，3，2，1为例，从小到大进行排序，第一次排序过程如下图：</p>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/4038f64f47975ab9f519e4f739e464e9.jpg" style="zoom: 50%;"></p>
<p>在一次排序操作后，6被正确归位。将这一操作重复6次便可完成排序操作。</p>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/9246f12cca22e5d872cbfce302ef4d09.jpg" alt="img" style="zoom:50%;"></p>
<p>实际上，当某次冒泡操作未进行数据交换时，说明已经完成排序操作，便可以跳过接下来的操作。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bubble_sort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)&#123;</span><br><span class="line">    <span class="comment">// 是否有数据交换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">array</span>.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 顶部存放的是已经归位的元素，因而每次交换时跳过顶部的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="built_in">array</span>.size()-i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = <span class="built_in">array</span>[j];</span><br><span class="line">                <span class="built_in">array</span>[j] = <span class="built_in">array</span>[j+<span class="number">1</span>];</span><br><span class="line">                <span class="built_in">array</span>[j+<span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前迭代没有数据交换，则跳出</span></span><br><span class="line">        <span class="keyword">if</span> (!flag)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序算法是原地排序算法，是稳定的排序算法。</p>
<h3 id="冒泡排序时间复杂度"><a href="#冒泡排序时间复杂度" class="headerlink" title="冒泡排序时间复杂度"></a>冒泡排序时间复杂度</h3><p>最好情况下，数组已经是有序的，只需要进行一次冒泡操作，时间复杂度为$O(n)$；最坏情况下，数组完全无序（倒序），需要进行n次冒泡操作，时间复杂度为$O(n)^2$。</p>
<p>因为对于一个数组，其中的元素的排列情况有很多种，而不同的排列情况算法执行的时间肯定不同。为了避免复杂的数学分析，引入“有序度”和“逆序度”两个概念。</p>
<blockquote>
<p>有序度指数组中具有有序关系的元素对的个数。</p>
</blockquote>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/a1ef4cc1999d6bd0af08d8417ee55220.jpg" style="zoom:50%;"></p>
<p>一个倒序排列的数组的有序度就是0，一个完全有序的数组的有序度就是$n*(n-1)/2$，即满有序度。</p>
<p>逆序度有有序度的定义刚好相反，存在这么一种关系：<strong>逆序度=满有序度-有序度</strong>。排序的过程就是提升有序度，降低逆序度的过程。</p>
<p>以数组4,5,6,3,2,1为例，有序度为3，排序后，满序度为15。</p>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/8890cbf63ea80455ce82490a23361134.jpg" style="zoom:50%;"></p>
<p>冒泡排序中有两个操作原子，比较和交换。每进行依次交换操作，有序度加1。无论如何改进算法，都要进行逆序度次交换操作，即$n*(n-1)/2$-初始有序度。</p>
<p>对于包含n个数据的数组，最坏情况下，初始有序度为0，要进行$n(n-1)/2$次交换操作；最好时不用进行交换操作。以中间情况为例$n(n-1)/4$，假设这种情况为中间情况。那么，平均情况下，需要进行$n(n-1)/4$次交换操作，比较操作多于或等于交换操作，复杂度上限为$O(n)^2$，因而平均复杂度为$O(n)^2$。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>对于一个有序的数组，为了在插入了新的数据后仍旧保持原数组的有序，我们需要把新的数组插入到正确的位置。</p>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/7b257e179787c633d2bd171a764171a6.jpg" alt="img" style="zoom: 33%;"></p>
<p>插入排序算法便是借鉴这一思想，对于一组待排序的数组，插入排序算法会维持两个区间：已排序区间和待排序区间。刚开始时，已排序区间中只有一个元素（数组的第一个元素）；接着，依次从待排序区间取数据，将其插入到已排序区间的合适位置，保证已排序区间一直有序；重复该过程，直到待排序区间中没有元素。</p>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/b60f61ec487358ac037bf2b6974d2de1.jpg" alt="img" style="zoom: 50%;"></p>
<p>上图中，左侧为已排序区间，右侧为待排序区间。</p>
<p>插入排序同样包含两种操作，一种是元素的比较，一种是元素的移动。对于待插入元素a，要将其于已排序区间中的元素依次进行比较，找到合适的插入位置；接着将插入位置后的元素向后顺序移动一位，再将元素插入。</p>
<p>对于不同的查找方法（从前往后和从后往前），元素的比较次数有区别。但对于同一个给定的初始序列，移动操作的次数固定，等于逆序度。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序（从小到大排序）</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; insert_sort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="built_in">array</span>.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">            <span class="comment">// 找到合适的插入位置(第一个比当前元素大的元素)，则将插入位置后的元素都后移</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt; <span class="built_in">array</span>[j])&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> move_index=i; move_index&gt;j+<span class="number">1</span>; move_index--)&#123;</span><br><span class="line">                    <span class="built_in">array</span>[move_index] = <span class="built_in">array</span>[move_index<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">array</span>[j] = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入排序算法是原地排序算法，是稳定的排序算法。</p>
<h3 id="插入排序时间复杂度"><a href="#插入排序时间复杂度" class="headerlink" title="插入排序时间复杂度"></a>插入排序时间复杂度</h3><p>最好情况下的时间复杂度，当数组是完全有序时，在每次插入操作时，从后往前进行查找，那么只需一次比较操作便可以找到正确的位置，因而最好时间复杂度为$O(n)$。</p>
<p>最坏情况下的时间复杂度，当数组是完全逆序时，在每次插入操作时都要移动数组的第一个位置后面的所有元素，因而时间复杂度为$O(n^2)$。</p>
<p>平均时间复杂度，对一个数组进行插入操作的平均时间复杂度为$O(n)$，每一次插入操作都相当于向一个数组中插入元素，因而平均时间复杂度为$O(n^2)$。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序同样将数组划分为两部分，每一从待排数组中选出最小的元素放在已排序数组的末尾。如下图所示：</p>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/32371475a0b08f0db9861d102474181d.jpg" alt="img" style="zoom:50%;"></p>
<p>选择排序未使用额外的存储空间，因而空间复杂度为$O(1)$。其最好、最坏和平均时间复杂度都是$O(n^2)$。选择排序算法不是稳定的算法，因为每次交换待排数组中的最小值时会破坏原始数据的顺序。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; selection_sort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">array</span>.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">int</span> min_index;</span><br><span class="line">        <span class="comment">// 找出未排序数组中的最小值和其对应的下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;<span class="built_in">array</span>.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; min) &#123;</span><br><span class="line">                min = <span class="built_in">array</span>[j];</span><br><span class="line">                min_index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="built_in">array</span>[i] = min;</span><br><span class="line">        <span class="built_in">array</span>[min_index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="为什么选择插入排序？"><a href="#为什么选择插入排序？" class="headerlink" title="为什么选择插入排序？"></a>为什么选择插入排序？</h2><p>在冒泡排序和插入排序的代码中，冒泡排序需要进行逆序度次数据交换操作，同样插入排序需要逆序度次数据移动操作。但是一次交换操作需要三步，而一次移动操作只需要一步。因而，虽然时间复杂度都是$O(n^2)$，但是在实际情况下，数据量较大时，插入排序优于冒泡排序。</p>
<p>上述三个排序算法的时间复杂度都是$O(n^2)$，适用于处理小规模的数据。在处理较大规模的数据时就需要用到接下来的两种时间复杂度为$O(nlogn)$的排序算法：归并排序和快速排序。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序和快速排序都用到了分治的思想，其中归并排序的思想是：如果要排序一个数组，可以将该数组划分为前后两个部分，再对两个部分分别进行排序，最后再将两个部分进行合并。如下图所示：</p>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/db7f892d3355ef74da9cd64aa926dc2b.jpg" alt="img" style="zoom:50%;"></p>
<p>所谓分治就是将大的问题分解为小的问题，小的问题被解决后，大的问题自然就被解决。分治的思想和递归的思想很相似，都是将问题进行拆分。因而自然可以使用递归来实现归并排序。</p>
<p>归并排序的递归代码的递推公式为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+<span class="number">1</span>…r))</span><br><span class="line"></span><br><span class="line">终止条件：</span><br><span class="line">p &gt;= r 不用再继续分解</span><br></pre></td></tr></table></figure>
<p>简单来说，就是分别对数组的两部分进行归并排序，再将排好序的两部分进行合并。</p>
<p>在编写合并代码时，有一个重要的前提条件是，此时两部分都是有序的，并且最终合并得到的数组也得是有序的。我们可以使用交替比较的方式进行合并：</p>
<ul>
<li>首先分别从两部分数组中取出第$i,j$个元素，比较$part1[i]$和$part2[j]$的大小，将两者中小的那个放入临时数组中，假设$part1[i]&lt;part2[j]$，就$part1[i]$放入临时数组中；</li>
<li>再从$part1$中取出下一个元素，与$part2[j]$比较大小，将较小的那个元素放入临时数组中。</li>
<li>重复这一过程，直到两个数组中有一个数组都被放入临时数组中，最后将另一个未遍历完的数组的剩余部分放到临时数组的尾部即可。</li>
</ul>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/95897ade4f7ad5d10af057b1d144a22f.jpg" alt="img" style="zoom:50%;"></p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; merge(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; part1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; part2)&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 将两个有序数组合并为有序数组</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">int</span> part1_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> part2_index = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; merge_array;</span><br><span class="line">    <span class="keyword">while</span>(part1_index &lt; part1.size() &amp;&amp; part2_index &lt; part2.size())&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = part1[part1_index];</span><br><span class="line">        <span class="keyword">int</span> num2 = part2[part2_index];</span><br><span class="line">        <span class="comment">// 将两者中较小的一个放入合并数组中</span></span><br><span class="line">        <span class="keyword">if</span> (num1 &lt; num2 || num1 == num2)&#123;</span><br><span class="line">            merge_array.push_back(num1);</span><br><span class="line">            part1_index++;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            merge_array.push_back(num2);</span><br><span class="line">            part2_index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将剩余的部分放入合并数组中</span></span><br><span class="line">    <span class="keyword">if</span> (part1_index == part1.size())&#123;</span><br><span class="line">        <span class="keyword">auto</span> start = part2.begin() + part2_index;</span><br><span class="line">        merge_array.insert(merge_array.end(), start, part2.end());</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> start = part1.begin() + part1_index;</span><br><span class="line">        merge_array.insert(merge_array.end(), start, part1.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> merge_array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; merge_sort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; unsorted_array)&#123;</span><br><span class="line">    <span class="keyword">if</span> (unsorted_array.size() == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> unsorted_array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; part1, part2;</span><br><span class="line">    part1.assign(unsorted_array.begin(), unsorted_array.begin()+unsorted_array.size()/<span class="number">2</span>);</span><br><span class="line">    part2.assign(unsorted_array.begin()+unsorted_array.size()/<span class="number">2</span>, unsorted_array.end());</span><br><span class="line"></span><br><span class="line">    part1 = merge_sort(part1);</span><br><span class="line">    part2 = merge_sort(part2);</span><br><span class="line">    <span class="keyword">return</span> merge(part1, part2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归并排序是不是稳定的算法？归并排序是不是稳定的算法主要取决于<code>merge()</code>函数，当遇到两个相同的值时，如果将左侧的元素先放入合并数组中，那么归并排序就是稳定的算法。</p>
<h3 id="归并排序时间复杂度"><a href="#归并排序时间复杂度" class="headerlink" title="归并排序时间复杂度"></a>归并排序时间复杂度</h3><p>归并排序是使用递归的方法实现的，分析递归算法的复杂度时会比较复杂。</p>
<p>递归的思想就是将一个复杂的问题分解为多个子问题进行求解，等子问题求解完成后，再将子问题的结果进行合并。如果定义求解问题a的时间为T(a)，求解问题b、c的时间分别为T(b)和T(c)。其中，问题a可以被分解为b和c。那么：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(a) = T(b) + T(c) + K</span><br></pre></td></tr></table></figure>
<p>其中，k对应合并两个子问题时耗费的时间。也就是说：</p>
<blockquote>
<p>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。</p>
</blockquote>
<p>对于归并排序，假设对n个元素进行归并排序所学的时间为T(n)，那么分解为两个子数组排序的时间是T(n/2)。<code>merge()</code>函数合并两个有序数组的时间复杂度为$O(n)$。那么，套用公式，归并排序的时间复杂度的计算公式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line">T(n) = 2*T(n/2) + n； n&gt;1</span><br></pre></td></tr></table></figure>
<p>对上述公式进行分解：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T(n) = 2*T(n/2) + n</span><br><span class="line">     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n</span><br><span class="line">     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n</span><br><span class="line">     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n</span><br><span class="line">     ......</span><br><span class="line">     = 2^k * T(n/2^k) + k * n</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure>
<p>可以将上述的$k$看作二分的次数，最终得到：</p>
<script type="math/tex; mode=display">
T(n)=2^k*T(\frac{n}{2^k})+k*n</script><p>令：$\frac{n}{2^k}=1$，得到$k=log_2n$，代回上式得到：</p>
<script type="math/tex; mode=display">
T(n)=n*T(1)+n*log_2n \\
T(n)=Cn+nlog_2n</script><p>使用大$O$表示法，时间复杂度为$O(nlogn)$。</p>
<blockquote>
<p>归并排序的执行效率与要排序的原始数组的有序程度无关，因而时间复杂度非常稳定。最好、最坏和平均时间复杂度都是$O(nlogn)$。</p>
</blockquote>
<p>归并排序的时间复杂度很好，但在空间复杂度方面，该算法不是原地排序算法。我们在执行合并函数时，需要开辟额外的数组存放合并后的数据，之前的三种排序算法都不需要使用额外的空间。</p>
<p>在进行归并排序的空间复杂度分析时，我们无法使用上述分析时间复杂度的方法。时间复杂度中，各个子数组的运算时间是可以累加的，但对于空间来说，当一个子数组运算完后，该子数组开辟的空间便会被释放，在任何一个时刻，只会有一个数组占用额外的合并空间，临时存储空间不会超过最大的数组的内存大小n，因而空间复杂度为$O(n)$。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>与归并排序类似，快速排序也使用了分治的思想。快速排序的思想如下：</p>
<p>从数组中任意选取一个数值，将数组中比该数组小的元素都放在该数值的左侧，比该数组大的元素都放在该数值的右侧。这样一来数组就被划分为两个部分，接着继续对左右两部分数组使用快速排序，直到数组的区间缩小为1，返回。</p>
<p>分区的思想如下图所示：</p>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/4d892c3a2e08a17f16097d07ea088a81.jpg" style="zoom:50%;"></p>
<p>将算法的思想用公式表述，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)</span><br><span class="line"></span><br><span class="line">终止条件：</span><br><span class="line">p &gt;= r</span><br></pre></td></tr></table></figure>
<p>在归并排序中比较重要的操作是<code>merge()</code>函数，而在快速排序中，比较重要的操作就是分区操作。</p>
<p>分区操作简单的实现方式就是，分别维持两个数组，将待分区数组中的元素依次与分区点元素进行比较，大的元素放到一个数组，小的元素放到另一个数组。但是这样一来，每次进行分区操作时都要分配额外的内存空间，进而导致快速排序算法不是原地排序算法。</p>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/6643bc3cef766f5b3e4526c332c60adc.jpg" alt="img" style="zoom:50%;"></p>
<p>那么如何实现在原始数组空间上进行分区操作？在选择排序中，我们使用交换的方法将未排序区间中的最小值和未排序区间中的首位值进行交换，以达到将最小值插入已排序数组的目的。这里，我们同样可以借助交换的思想，在原始数组中维持两个部分，左侧为偏小的值的区间。</p>
<p>对于未比较的元素，将其与分区点处的值进行比较，如果小或等于分区点，就将其交换到偏小的值的区间。因而，在实际程序实现时，我们需要使用一个下标$i$指示偏小值的区间的范围，另一个下标$j$指示当前遍历到的元素的位置。如下图所示：</p>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/086002d67995e4769473b3f50dd96de7.jpg" alt="img" style="zoom:50%;"></p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">separate_partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; unsorted_array, <span class="keyword">int</span> start_index, <span class="keyword">int</span> end_index)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注意unsorted_array需要使用引用的方式，因为需要在分区函数中改变数组元素的位置</span></span><br><span class="line">    <span class="keyword">int</span> separate_point = unsorted_array[end_index];</span><br><span class="line">    <span class="keyword">int</span> separate_index = start_index;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = start_index; j&lt;end_index; j++)&#123;</span><br><span class="line">        <span class="comment">// 如果当前值小于或等于分区值，则将当前值交换到已整理区间，已整理区间的下标前移</span></span><br><span class="line">        <span class="keyword">if</span> (unsorted_array[j] &lt; separate_point)&#123;</span><br><span class="line">            swap_numbers(unsorted_array[separate_index], unsorted_array[j]);</span><br><span class="line">            separate_index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap_numbers(unsorted_array[end_index], unsorted_array[separate_index]);</span><br><span class="line">    <span class="keyword">return</span> separate_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub_quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;unsorted_array, <span class="keyword">int</span> start_index, <span class="keyword">int</span> end_index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start_index &gt; end_index || start_index == end_index)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 划分分区</span></span><br><span class="line">    <span class="keyword">int</span> separate_index = separate_partition(unsorted_array, start_index, end_index);</span><br><span class="line">    <span class="comment">// 对较小值和较大值区间分别排序</span></span><br><span class="line">    sub_quick_sort(unsorted_array, start_index, separate_index<span class="number">-1</span>);</span><br><span class="line">    sub_quick_sort(unsorted_array, separate_index+<span class="number">1</span>, end_index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; quick_sort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; unsorted_array)&#123;</span><br><span class="line">    sub_quick_sort(unsorted_array, <span class="number">0</span>, unsorted_array.size()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> unsorted_array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在编写快排的代码时，要特别注意值传递的方式（因为要在函数内部改变数组的元素位置，所以应该使用引用进行值传递）。除此之外，要注意分区代码的书写，以及区间索引的计算。</p>
<h3 id="归并排序和快速排序的差别"><a href="#归并排序和快速排序的差别" class="headerlink" title="归并排序和快速排序的差别"></a>归并排序和快速排序的差别</h3><p>从两个排序算法的思想上我们可以看出，归并排序是一种自下而上的排序方法，将未排序数组迭代拆分为两个部分，在对两个部分进行排序，接着使用合并函数将两部分合并为有序的数组；而快速排序是一种自上而下的排序方法，首先将未排序数组依据分区点划分为宏观有序的两个部分，接着再对两个部分依次进行划分，最后每一个小部分都有序，原始数组也就有序。两种排序算法的对比如下：</p>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/aa03ae570dace416127c9ccf9db8ac05.jpg" alt="img" style="zoom:50%;"></p>
<p>归并排序自下而上的排序方法导致其必须再合并函数中使用额外的数组进行合并，是一种非原地的排序算法；而再快速排序算法中，经过特殊设计的分区函数可以再原地完成划分，是一种原地排序算法，<strong>占用的内存更少</strong>。</p>
<h3 id="快速排序的性能"><a href="#快速排序的性能" class="headerlink" title="快速排序的性能"></a>快速排序的性能</h3><p>快排同样是递归操作，如果每次进行分区时都能够将数组划分为大小相同的两个子数组，那么其时间复杂度的计算公式和归并排序相同。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line">T(n) = 2*T(n/2) + n； n&gt;1</span><br></pre></td></tr></table></figure>
<p>进而时间复杂度为$O(nlogn)$。</p>
<p>但是并不是每一次划分都能够将数组划分为大小相同的两个部分。假设每次分区操作都将区间分成大小为$9:1$的区间。那么递归时间复杂度公式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line"></span><br><span class="line">T(n) = T(n/10) + T(9*n/10) + n； n&gt;1</span><br></pre></td></tr></table></figure>
<p>该递归公式的求解方式比较复杂，再原文中作者未讲明，只是给出了：</p>
<p>快速排序在大部分情况下的时间复杂度都是$O(nlogn)$，只有极端情况下才是$O(n^2)$。</p>
<h2 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h2><p>有10个接口访问日志文件，每个日志文件约300MB，每个文件里的日志都按照时间戳从小到大进行排序。要求将这10个日志文件合并为一个日志文件，合并后的日志仍然按照时间戳从小到大进行排序。限定处理该任务的机器只有1Gb内存，如何“快速”将这10个日志文件合并？</p>
<p>解决这个问题可以借助归并排序中合并函数的做法，在合并函数中依次取两个子数组中的值，将较小的一个值放入合并数组中，再从较小的值对应的子数组中取下一个值，与上一次的残留值进行比较，较小的继续放入合并数组中。将上述过程交替进行即可得到最终的合并数组。</p>
<p>在本问题中有内存的限制，意味着我们无法以下把所有文件都读入到内存中。因而，我们可以借助合并函数的思想，一次分别从10个日志文件中读入10条日志，将这10条日志中最小的那个日志写入文件中，接着从最小的日志的文件中读入下一个数据，与剩余的9条数据进行比较选出最小值写入文件中。接着再读入一条数据，迭代进行上述步骤，直到有九个文件中的数据依次被读完，将剩余的一个文件中的剩余数据写入到合并文件的尾部即可。</p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>上面几个排序算法的时间复杂度要么是$O(n^2)$，要么是$O(nlogn)$，都是非线性的排序算法，接下来将了解几种线性排序算法。</p>
<p>所谓桶排序，就是借助“桶”进行排序，核心思想是将要排序的数据分到几个有序的桶里，再对每个桶里的数据单独进行排序，最后，将每个桶里的数据按照顺序取出，得到的序列就是有序的。</p>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/987564607b864255f81686829503abae.jpg" alt="img" style="zoom:50%;"></p>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>假设要排序的数据有n个，将其平均划分到m个桶内，每个桶中有k-n/m个元素，对每个桶中的数据使用快速排序，时间复杂度为$O(klogk)$。m个桶排序的时间复杂度就是$O(m<em>k</em>logk)$，代入k=n/m，那么桶排序的时间复杂度为$O(n*log(n/m))$，当所使用的桶的数目接近数据个数n时，$log(n/m)$就会非常小，此时桶排序的时间复杂度就是$O(n)$。</p>
<p>通过上述分析过程，我们会发现有很多限制，</p>
<ul>
<li>首先需要待排序的数据能够恰好被平均划分到m个桶中；</li>
<li>桶与桶之间存在一定的大小顺序，这样桶内排序完成后不需要对桶之间进行排序；</li>
<li>桶与桶之间的数据分布比较均匀，如果数据分布非常不均匀，桶与桶之间的排序时间复杂度相差就会非常大，极端情况下，所有的数据全部集中在单个桶中，此时如果使用快排进行桶内排序，总体的时间复杂度就是$O(nlogn)$。</li>
</ul>
<blockquote>
<p>桶排序适用于外部排序，即数据存储在外部磁盘中，数据量比较大，无法全部加载到内存中。</p>
</blockquote>
<p>例如，有10GB的订单数据，希望按照订单金额（正整数）进行排序，内存有限，应该怎么办？</p>
<p>可以对文件进行扫描，按照订单大小范围将订单存放到100个桶中，这100个桶之间是有序的，比如第一个桶存放金额在1到1000元之间的订单，第二个桶存放1001到2000元之间的订单。每一个桶对应一个文件，按照金额范围的大小顺序给文件命名（00,01,02，…，99）。</p>
<p>如果订单分布均匀，就可以得到100个大小为100MB的文件，依次将这些文件加载到内存中，进行排序，完成排序后，按照文件顺序合并为一个文件即可。</p>
<p>当订单分布不均匀时，可以继续对订单数据较多的文件进行划分，直到所有文件都能被读入内存中。</p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序是桶排序的特例，当要排序的数据所处的范围不大时，假设最大值是k，便可以将数据划分到k个桶中，桶内的数据值相同，就不需要进行桶内排序。</p>
<p>需要做的就是，对数据进行两次遍历，第一次将数据放入对应的桶中，第二次遍历所有桶，依次取出放入到另一个数组中即可。因而，时间复杂度为$O(n)$。</p>
<p>那么，为什么称为“计数排序”？</p>
<p>假设有大小从0到5的数据，使用大小为6的数组表示桶，下标对应值，存储的元素为当前值的个数，对所有数据进行遍历便可以得到每一个下标对应的值的元素个数：</p>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/adc75672ef33fa54b023a040834fcbc9.jpg" alt="img" style="zoom: 33%;"></p>
<p>依据上述数组可以得到值为3的元素有3个，小于3的元素有4个，因而值为3的元素在排序后的数组中占的下标为4、5、6。</p>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/361f4d781d2a2d144dcbbbb0b9e6db29.jpg" alt="img" style="zoom:33%;"></p>
<p>那么如何得到每个元素在排序后的数组中的位置呢？可以对C[6]数组进行累积求和，得到如下数组：</p>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/dd6c62b12b0dc1b3a294af0fa1ce371f.jpg" alt="img" style="zoom:33%;"></p>
<p>数组中的元素表示小于等于下标对应的值的元素个数。接从后往前（可以保证稳定性，从前往后不能保证稳定性）对原始数组进行扫描，当数值为3时，从上个数组中得到小于等于3的元素的个数，此时为7，则将3填入第7个位置，即下标为6，接着将C[3]的值减1。接着对剩下的元素依次执行上述过程，扫描完整个数组便可以得到最终的有序数组：</p>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/1d730cb17249f8e92ef5cab53ae65784.jpg" alt="img" style="zoom:33%;"></p>
<p>整个过程对原始数组进行了两次扫描，第一次扫描得到各个值的个数，第二次扫描将各个值填入其对应的位置；除此之外，对计数数组进行了三次遍历，第一次填入值个数，第二次计算累积个数，第三次依据值个数将原始数据的各个元素填入排序数组中，因而时间复杂度为$O(n)$。</p>
<p>计数排序最重要的思想便是使用一个数组来对原始数组中的元素的数目进行计数，按照元素的大小顺序依次记录其对应的个数。</p>
<blockquote>
<ul>
<li><p>计数排序只适用于数据范围不大的情况，如果数据的范围k比要排序的数据n大的多，就不适合使用计数排序。</p>
</li>
<li><p>计数排序只适用于非负整数（数要被用作计数数组的下标），如果要排序的数据是其它类型，要将其在不改变相对大小的情况下转换为非负整数。</p>
</li>
</ul>
</blockquote>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>那么当待排序数组中的数据的范围过大时，有没有时间复杂度为$O(n)$的算法？</p>
<p>假设现在有十万个手机号码，要对这些手机号码从小到大进行排序。这个问题有这样的规律，如果在前几位号码中，一个手机号码已经大于另一个手机号码，就不需要比较后续的几位。</p>
<p>可以采用下面的思路，先按照最后一位进行排序，再按照倒数第二位进行排序，以此类推直到第一位。以字符串排序为例，基数排序的思路如下所示：</p>
<p><img src="/2019/11/09/shu-ju-jie-gou-yu-suan-fa/suan-fa/pai-xu/df0cdbb73bd19a2d69a52c54d8b9fc0c.jpg" alt="img" style="zoom: 50%;"></p>
<p>为了保证基数排序算法的有效性，每一位排序所采用的算法需要是稳定的，也就是说再对高位进行排序时，不能打乱低位的有序性。</p>
<p>通过使用基数排序，在对每一位进行排序时，所要处理的数据的范围将会很小，此时就可以借助桶排序或者计数排序实现单个位的排序。单个位的排序是$O(n)$，这样当原始数据的位数较少时，基数排序算法的时间复杂度就是$O(n)$，属于线性排序算法。</p>
<p>当待排序的数据并不是等长时，可以采取高位补零的方法将数据变为等长后，再使用基数排序算法。</p>
<blockquote>
<p>基数排序对数据有要求：</p>
<ul>
<li>需要可以分割出独立的“位”来比较，位之间有递进关系，高位大，则原始数据大。</li>
<li>每一位的范围不能太大，要可以使用线性算法进行排序。</li>
</ul>
</blockquote>
<p>桶排序、计数排序和基数排序都对数据有着较为严格的要求，应用不广泛。通排序和计数排序的排序思路很相似，都是针对范围不大的数据，将数据划分成不同的桶来实现排序。基数排序需要数据能够划分为高低位，并且高低位之间存在递进关系，且每一位的数据范围不能太大。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/column/article/41913" target="_blank" rel="noopener">王争-数据结构与算法之美</a></li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/编程基础/" rel="tag"># 编程基础</a>
          
            <a href="/tags/算法/" rel="tag"># 算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/24/python/python-mian-xiang-dui-xiang/" rel="next" title="Python面向对象基础">
                <i class="fa fa-chevron-left"></i> Python面向对象基础
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/12/python/python-zhong-de-die-dai-qi-he-sheng-cheng-qi/" rel="prev" title="Python中的迭代器和生成器">
                Python中的迭代器和生成器 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="gitalk-container">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/image.jpg" alt="MXQ">
            
              <p class="site-author-name" itemprop="name">MXQ</p>
              <p class="site-description motion-element" itemprop="description">Keep Thinking Keep Moving</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">37</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#排序算法"><span class="nav-number">1.</span> <span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#如何分析一个排序算法？"><span class="nav-number">1.1.</span> <span class="nav-text">如何分析一个排序算法？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#排序算法的执行效率"><span class="nav-number">1.1.1.</span> <span class="nav-text">排序算法的执行效率</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最好情况、最坏情况和平均情况时间复杂度"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">最好情况、最坏情况和平均情况时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度的系数、常数和低阶"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">时间复杂度的系数、常数和低阶</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#比较和交换次数"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">比较和交换次数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序算法的内存消耗"><span class="nav-number">1.1.2.</span> <span class="nav-text">排序算法的内存消耗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序算法的稳定性"><span class="nav-number">1.1.3.</span> <span class="nav-text">排序算法的稳定性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#冒泡排序（Bubble-Sort）"><span class="nav-number">1.2.</span> <span class="nav-text">冒泡排序（Bubble Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代码"><span class="nav-number">1.2.1.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#冒泡排序时间复杂度"><span class="nav-number">1.2.2.</span> <span class="nav-text">冒泡排序时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入排序"><span class="nav-number">1.3.</span> <span class="nav-text">插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代码-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插入排序时间复杂度"><span class="nav-number">1.3.2.</span> <span class="nav-text">插入排序时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择排序"><span class="nav-number">1.4.</span> <span class="nav-text">选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代码-2"><span class="nav-number">1.4.1.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么选择插入排序？"><span class="nav-number">1.5.</span> <span class="nav-text">为什么选择插入排序？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#归并排序"><span class="nav-number">1.6.</span> <span class="nav-text">归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代码-3"><span class="nav-number">1.6.1.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#归并排序时间复杂度"><span class="nav-number">1.6.2.</span> <span class="nav-text">归并排序时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速排序"><span class="nav-number">1.7.</span> <span class="nav-text">快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代码-4"><span class="nav-number">1.7.1.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#归并排序和快速排序的差别"><span class="nav-number">1.7.2.</span> <span class="nav-text">归并排序和快速排序的差别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速排序的性能"><span class="nav-number">1.7.3.</span> <span class="nav-text">快速排序的性能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问题思考"><span class="nav-number">1.8.</span> <span class="nav-text">问题思考</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#桶排序"><span class="nav-number">1.9.</span> <span class="nav-text">桶排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#时间复杂度分析"><span class="nav-number">1.9.1.</span> <span class="nav-text">时间复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计数排序"><span class="nav-number">1.10.</span> <span class="nav-text">计数排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基数排序"><span class="nav-number">1.11.</span> <span class="nav-text">基数排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">1.12.</span> <span class="nav-text">参考</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <!-- 新增访客统计代码 -->

<div class="busuanzi-count">
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="site-uv">
      <i class="fa fa-user"></i>
      访问用户： <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人
    </span>
    <div class="powered-by"></div>
    <span class="site-uv">
      <i class="fa fa-eye"></i>
      访问次数： <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次
    </span>
    <!-- 博客字数统计 -->
    <span class="site-pv">
      <i class="fa fa-pencil"></i>
      博客全站共： <span class="post-count">89.3k</span> 字
    </span>
</div>
<!-- 新增访客统计代码 END-->

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MXQ</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.7.0</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>




  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  


  
    

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">



<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: '7cf4fc787f067d6dee7f',
    clientSecret: 'a2a33207ac87439208ed09d72fd8a3c485c9e6e7',
    repo: 'GitTalk',
    owner: 'xiangqianma',
    admin: ['xiangqianma'],
    id: md5(location.pathname),
    distractionFreeMode: 'true'
  });
  gitalk.render('gitalk-container');
</script>

  


  





  

  

  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: "AMS"
      }
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
  overflow: auto hidden;
}
</style>

    
  


  

  

  

  

  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end --></body>
</html>
